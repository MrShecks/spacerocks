import math
import pygame

from gamelib import sprite
from gamelib import tileset

from abc import ABC, abstractmethod


class PlayerWeapon (ABC):

    def __init__ (self, player_ship):
        self.__player_ship = player_ship

    @abstractmethod
    def fire (self):

        """
            Fire the weapon creating one or more projectiles

            :return: Array of projectiles generated by firing the weapon

        """

    def can_fire (self):
        return True

    def get_player_ship (self):
        return self.__player_ship

    def update (self, dt):
        pass

class Missile (sprite.KinematicSprite):

    MISSILE_WIDTH           = 39
    MISSILE_HEIGHT          = 39

    DEFAULT_VELOCITY        = 3000   # Default velocity in pixels per second
    DEFAULT_TIME_TO_LIVE    = 5     # Default TTL in seconds

    def __init__ (self, x, y, image, velocity, angle, time_to_live = DEFAULT_TIME_TO_LIVE):
        super ().__init__ (x, y, [image], 0, velocity)

        self._time_to_live = time_to_live
        self.set_rotation (angle)
        self.set_max_velocity (5000, 5000)

    def update (self, dt):
        super ().update (dt)

        self._time_to_live -= dt

        if self._time_to_live <= 0:
            self.kill ()

class Photon (sprite.KinematicSprite):

    WIDTH           = 42
    HEIGHT          = 76

    COLOR_GREEN     = 0
    COLOR_YELLOW    = 1
    COLOR_RED       = 2
    COLOR_WHITE     = 3

    VELOCITY        = 3000      # Default velocity in pixels per second
    TIME_TO_LIVE    = 0.5       # Default TTL in seconds

    def __init__ (self, x, y, image, scale, velocity, angle, screen_rect, time_to_live = TIME_TO_LIVE):
        super ().__init__ (x, y, [image], 0, velocity)

        self._screen_rect = screen_rect
        self._time_to_live = time_to_live

        self.set_scale (scale)
        self.set_rotation (angle)
        self.set_max_velocity (Photon.VELOCITY, Photon.VELOCITY)

    def update (self, dt):
        super ().update (dt)

        # TODO: At some point might need to think about pooling projectiles for performance
        
        self._time_to_live -= dt

        if self._time_to_live <= 0 or self._screen_rect.colliderect (self.rect) == False:
            self.kill ()

    @classmethod
    def get_tileset (cls, image_cache):
        return tileset.TileSet (image_cache.get ('photon_set_01'), Photon.WIDTH, Photon.HEIGHT)


class SingleShot (PlayerWeapon):

    """
        SingleShot - Fires a single missile from the from of the player ship

        Note: This should the basic primary weapon the player starts with. Variations could
        could be created by modifying the velocity, TTL and cool-down values

    """

    _COOLDOWN_TIMER = 50

    def __init__ (self, player_ship, image_cache):
        super ().__init__ (player_ship)

        self._tiles = Photon.get_tileset (image_cache)
        self._last_update = pygame.time.get_ticks ()
        self._can_fire = True

    def can_fire (self):
        return self._can_fire

    def fire (self):
        ship = self.get_player_ship ()

        x = ship.rect.centerx
        y = ship.rect.centery

        velocity = ship.velocity + (ship.get_forward_vector () * Photon.VELOCITY)
        missile = Photon (x, y, self._tiles.get_tile (Photon.COLOR_GREEN), ship.scale,
                          velocity, ship.rotation, ship.screen_rect)

        return [ missile ]

    def update (self, dt):
        now = pygame.time.get_ticks ()

        if now - self._last_update >= SingleShot._COOLDOWN_TIMER:
            self._last_update = now
            self._can_fire = True
        else:
            self._can_fire = False


class DoubleShot (PlayerWeapon):

    def __init__ (self, player_ship, image_cache):
        super ().__init__ (player_ship)

        self._tiles = Photon.get_tileset (image_cache)

    def fire (self):
        ship = self.get_player_ship ()
        velocity = ship.velocity + (ship.get_forward_vector () * Photon.VELOCITY)


        # FIXME: Don't hardcode the gun positions, since we will have different ships it would be better
        # FIXME: to ask the ship (e.g ship.get_cannon_position (x) )

        mp1 = pygame.math.Vector2 (-35, 0)
        mp1.rotate_ip (ship.rotation)

        mp1.x += ship.position.x
        mp1.y += ship.position.y


        missile1 = Photon (mp1.x, mp1.y, self._tiles.get_tile (Photon.COLOR_RED), ship.scale,
                           velocity, ship.rotation, ship.screen_rect)

        mp2 = pygame.math.Vector2 (35, 0)
        mp2.rotate_ip (ship.rotation)

        mp2.x += ship.position.x
        mp2.y += ship.position.y

        missile2 = Photon (mp2.x, mp2.y, self._tiles.get_tile (Photon.COLOR_RED), ship.scale,
                           velocity, ship.rotation, ship.screen_rect)

        return [ missile1, missile2 ]


class RadialShot (PlayerWeapon):

    """
        RadialShot - Fires several missiles radiating from the center of the player ship in a circle

        Note: This might be a good secondary weapon obtained via a power up
    """

    DEFAULT_VELOCITY        = 800   # Default velocity in pixels per second
    DEFAULT_TIME_TO_LIVE    = 2     # Default TTL in seconds
    DEFAULT_MISSILE_COUNT   = 20    # Default number of missiles to fire

    def __init__ (self, player_ship, images):
        super ().__init__ (player_ship)
        self._tiles = tileset.TileSet (images.get ('missile_set'), Missile.MISSILE_WIDTH, Missile.MISSILE_HEIGHT)

    def fire (self):
        player_ship = self.get_player_ship ()
        missiles = []

        for angle in range (0, 360, 360 // RadialShot.DEFAULT_MISSILE_COUNT):
            radians = math.radians (angle)
            forward = pygame.math.Vector2 (math.cos (radians), -math.sin (radians))

            missile_velocity = player_ship.velocity + (forward * RadialShot.DEFAULT_VELOCITY)

            x = player_ship.rect.centerx + (forward.x * player_ship.rect.width / 2)
            y = player_ship.rect.centery + (forward.y * player_ship.rect.width / 2)

            missiles.append (Missile (x, y, self._tiles.get_tile (0),
                                      missile_velocity, 0, RadialShot.DEFAULT_TIME_TO_LIVE))

        return missiles